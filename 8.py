# -------------------------- # 1 # -------------------------- #

# 1. Реализовать класс «Дата», функция-конструктор которого должна принимать дату в виде строки
# формата «день-месяц-год». В рамках класса реализовать два метода. Первый, с декоратором @classmethod,
# должен извлекать число, месяц, год и преобразовывать их тип к типу «Число».
# Второй, с декоратором @staticmethod, должен проводить валидацию числа, месяца и года
# (например, месяц — от 1 до 12). Проверить работу полученной структуры на реальных данных.


class Data:
    """Создание класса Data"""

    @classmethod
    def data(cls):
        data = cls.format1()
        try:
            print(f'day: {int(data[0])}, month: {int(data[1])},'
                    f'year: {int(data[2])}')
        except TypeError:
            print('You entered incorrect data.')

    @staticmethod
    def format1():
        while True:
            enter_data = input('\nPlease enter the date in the format 12-12-1234: ')
            try:
                date_list = enter_data.split('-')
                if not (1 <= int(date_list[0]) <= 31):
                    print('A month can be from 1 to 31 days.')
                elif not (1 <= int(date_list[1]) <= 12):
                    print("The number of the month must be from 1 to 12.")
                elif not(1000 <= int(date_list[2]) <= 2020):
                    print('Enter the year from 1000 to 2020.')

            except (ValueError, IndexError):
                print('You entered incorrect data.')

            else:
                print(f'\nThe number of the day: {int(date_list[0])}\n'
                      f'The number of the mon: {int(date_list[1])}\n'
                      f'Year number: {int(date_list[2])}')
                break


a = Data()
a.format1()

# -------------------------- # 2 # -------------------------- #

# 2. Создайте собственный класс-исключение, обрабатывающий ситуацию деления
# на нуль. Проверьте его работу на данных, вводимых пользователем.
# При вводе пользователем нуля в качестве делителя программа должна
# корректно обработать эту ситуацию и не завершиться с ошибкой.


class MyError(Exception):
    """Создание класса-исключения"""
    def __init__(self, txt):
        self.txt = txt


def division():
    """Функция для обработки исключений"""
    try:
        x = int(input('Введите делитель: '))
        y = int(input('Введите делимое: '))

        if y == 0:
            raise MyError('На ноль делить нельзя.')
        return float('{:.3f}'.format(x / y))
        # 2 Знака после запятой

    except MyError as err:
        return err
    except:
        return 'Такие данные не делятся'


print(division())

# -------------------------- # 3 # -------------------------- #

# 3. Создайте собственный класс-исключение, который должен проверять содержимое списка на наличие только чисел.
# Проверить работу исключения на реальном примере. Необходимо запрашивать у пользователя данные и заполнять список.
# Класс-исключение должен контролировать типы данных элементов списка.
# Примечание: длина списка не фиксирована. Элементы запрашиваются бесконечно, пока пользователь сам не остановит работу
# скрипта, введя, например, команду “stop”. При этом скрипт завершается, сформированный список выводится на экран.
# Подсказка: для данного задания примем, что пользователь может вводить только числа и строки. При вводе пользователем
# очередного элемента необходимо реализовать проверку типа элемента и вносить его в список, только если введено число.
# Класс-исключение должен не позволить пользователю ввести текст (не число) и отобразить соответствующее сообщение.
# При этом работа скрипта не должна завершаться.


class MyError(Exception):

    def __init__(self):
        self.l = []

    def data(self):
        global n
        while True:
            try:
                try:
                    n = int(input('Добавьте число в список или нажмите "q" для выхода: '))
                    self.l.append(n)
                    if n == 'q':
                        print(f'Ваш список числел {self.l}')
                        break
                except ValueError:
                    raise MyError
            except MyError:
                print('В список будут добавлны только числа.')
                self.data()


b = MyError()
b.data()

# -------------------------- # 4-6 # -------------------------- #

# 4. Начните работу над проектом «Склад оргтехники». Создайте класс, описывающий склад. А также класс «Оргтехника»,
# который будет базовым для классов-наследников. Эти классы — конкретные типы оргтехники (принтер, сканер, ксерокс).
# В базовом классе определить параметры, общие для приведенных типов. В классах-наследниках реализовать параметры,
# уникальные для каждого типа оргтехники.
# 5. Продолжить работу над первым заданием. Разработать методы, отвечающие за приём оргтехники на склад и передачу в
# определенное подразделение компании. Для хранения данных о наименовании и количестве единиц оргтехники, а также других
# данных, можно использовать любую подходящую структуру, например словарь.
# 6. Продолжить работу над вторым заданием. Реализуйте механизм валидации вводимых пользователем данных.
# Например, для указания количества принтеров, отправленных на склад, нельзя использовать строковый тип данных.
# Подсказка: постарайтесь по возможности реализовать в проекте «Склад оргтехники» максимум возможностей, изученных
# на уроках по ООП.


class OfficeEquipment:

    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity
        self.goods = {}

    def income(self):
        try:
            self.name = input(f'Введите наименование: ')
            self.price = int(input(f'Введите цену за ед: '))
            self.quantity = int(input(f'Введите количество: '))
            good = {'Устройство': self.name, 'Стоимостью': self.price, 'В количестве': self.quantity}
            self.goods.update(good)
            print(self.goods)
        except ValueError:
            print('На складе этого нет')
            print(self.goods)


class Printer(OfficeEquipment):
    pass


class Scanner(OfficeEquipment):
    pass


class Xerox(OfficeEquipment):
    pass


p = Printer()
s = Scanner()
x = Xerox()
p.income()
s.income()
x.income()

# -------------------------- # 7 # -------------------------- #

# 7. Реализовать проект «Операции с комплексными числами». Создайте класс «Комплексное число», реализуйте перегрузку
# методов сложения и умножения комплексных чисел. Проверьте работу проекта, создав экземпляры класса (комплексные числа)
# и выполнив сложение и умножение созданных экземпляров. Проверьте корректность полученного результата.


class ComplexNumber:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __add__(self, other):
        return f'Сумма равна: {self.a + other.a} + {self.b + other.b} * i'

    def __mul__(self, other):
        return f'{self.a * other.a - self.b * other.b} + {self.a * other.b + other.a * self.b} * i'


c_1 = ComplexNumber(5, -23)
c_2 = ComplexNumber(26, 14)
print(c_1 + c_2)
print(c_1 * c_2)

# -------------------------- #   # -------------------------- #